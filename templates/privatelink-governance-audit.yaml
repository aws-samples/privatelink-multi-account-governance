AWSTemplateFormatVersion: 2010-09-09
Description: Solution Stack for Event Driven architecture for Multi-account PrivateLink Governance.
Parameters:
  AllowedPrivateLinkPartnerServices: 
    Type: String
    MinLength: '1'
    Description: Name of the Partner to whom PrivateLink connections are allowed. 
  AWSOrganizationId:
    Type: String
    MinLength: '1'
    Description: AWS Organizations ID for your AWS Organizations in the management account
  CloudTrailEventNotificationEmail:
    Type: String
    MinLength: '1'
    Description: Email Address of an Admin who will receive notifications of CloudTrail Events indicating policy voilations
Resources:
  CentralEventBusPolicy:
      Type: AWS::Events::EventBusPolicy
      Properties: 
        StatementId: 'AllowAllAccountsFromOrganizationToPutEvents'
        Statement: 
          Effect: Allow
          Principal: '*'
          Action: 
            - 'events:PutEvents'
          Resource: !Sub 'arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:event-bus/default'
          Condition:
            StringEquals:
              aws:PrincipalOrgID: !Ref AWSOrganizationId
  PLNotificationSnsTopic:
    Type : AWS::SNS::Topic
    Properties:
        Subscription:
          - Endpoint:  !Ref CloudTrailEventNotificationEmail
            Protocol: "email"
  PLNotificationTopicPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties:
      Topics:
        - !Ref PLNotificationSnsTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action: 'sns:Publish'
            Resource: !Ref PLNotificationSnsTopic
            Principal:
              Service: 'lambda.amazonaws.com'              
  PLNotificationsLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref PLNotificationsLambda
      Principal: events.amazonaws.com
  PLNotificationsLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: "PLNotificationsLambda"
      Description: Function to handle notifications from privatelink services 
      Handler: index.lambda_handler
      Role: 
        'Fn::GetAtt': 
          - PLNotificationsLambdaRole
          - Arn
      Code:
        ZipFile: |
            from __future__ import print_function
            import boto3
            import os
            import json
            import xml.etree.ElementTree as ET
            from botocore.exceptions import ClientError
            ec2 = boto3.client('ec2')
            allowedPrivatelinkServices = os.environ['ALLOWED_PRIVATELINK_SERVICES']
            #cloudTrailNotificationEmail = os.environ['CLOUDTRAIL_NOTIFICATION_EMAIL']
            cloudTrailNotificationEmail = ""
            def lambda_handler(event, context):                
                if (event and event['detail']['eventName'] == 'CreateVpcEndpoint'):
                    print(f"CreateVPCEndpoint is called")
                    plServiceName = event['detail']['requestParameters']['CreateVpcEndpointRequest']['ServiceName']
                    plServiceOwner= event['detail']['responseElements']['CreateVpcEndpointResponse']['vpcEndpoint']['ownerId']
                    VPCEndPointID= event['detail']['responseElements']['CreateVpcEndpointResponse']['vpcEndpoint']['vpcEndpointId']
                    plAccountinOrgs = get_organizations_accounts(plServiceOwner)
                    if plServiceName in allowedPrivatelinkServices and not plServiceOwner == 'amazon' and not plAccountinOrgs:
                        print(f"CreateVPCEndpoint is NOT allowed for accounts that are not owned by amazon. Inform Cloud Admin")
                        snsMessage="Action Required:, Privatelink VPC Endpoint created by AWS Account ID - "+str(plServiceOwner)+" with VPCEndpointID - "+str(VPCEndPointID)+" and VPCEndPoint Service Name - "+str(plServiceName)+" and NOT ALLOWED. check Cloudtrail or Cloudwatch logs for addtional information."
                        send_sns_message(snsMessage) 
                    else:
                        print(f"CreateVPCEndpoint is allowed, VPCendpoint was requested by either Account in Orgs or Amazon owned Services or through Allowed Private Link Services")
                        snsMessage = "Informational Message:  Privatelink VPC Endpoint created by AWS Account ID - "+str(plServiceOwner)+" with VPCEndpointID - "+ str(VPCEndPointID)+" and VPCEndPoint Service Name - "+str(plServiceName)+", no futher action required."
                        send_sns_message(snsMessage)   
                elif (event and event['detail']['eventName'] == 'AcceptVpcEndpointConnections'):
                    print(f"AcceptVpcEndpointConnections is called") 
                    AcceptVPCEndPointServiceName = event['detail']['requestParameters']['AcceptVpcEndpointConnectionsRequest']['ServiceId']
                    AcceptVPCEndPointID = event['detail']['requestParameters']['AcceptVpcEndpointConnectionsRequest']['VpcEndpointId']['content']
                    ReceiptAWSAccountID= event['detail']['recipientAccountId']
                    print(ReceiptAWSAccountID)
                    snsMessage="Review and Action Needed: VPC endpoint connection was manually accepted by Recipient AWS AccountID - "+str(ReceiptAWSAccountID)+" for VPC EndPointID - "+str(AcceptVPCEndPointID)+" and VPCEndPoint Service Name - "+str(AcceptVPCEndPointServiceName)
                    send_sns_message(snsMessage)
                else:
                    print(f"Some other event. Ignore")

            def get_organizations_accounts(plServiceOwner):    
                organization= boto3.client('organizations')
                response = organization.list_accounts()
                if 'NextToken' in response:
                    response = organization.list_accounts(NextToken=response['NextToken'])
                    for account in response['Accounts']:
                        if plServiceOwner==account['Id']:
                            return True
                else:
                    response = organization.list_accounts()
                    for account in response['Accounts']:
                        print(account['Id'])
                        if plServiceOwner==account['Id']:
                            return True
                return False

            def send_sns_message(snsMessage):
                snsClient = boto3.client('sns')
                topicArn = os.environ['SNS_TOPIC_ARN']
                try:
                    response = snsClient.publish(TopicArn=topicArn,Message=snsMessage)
                except ClientError as e:
                    print("SNS Delivery Failed! ", e.response['Error']['Message'])
                else:
                    print("SNS Message  successfully sent to " + topicArn + "!")          
      Runtime: python3.12
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          ALLOWED_PRIVATELINK_SERVICES: !Ref AllowedPrivateLinkPartnerServices
          SNS_TOPIC_ARN: !Ref PLNotificationSnsTopic
  PLNotificationsLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      Description: Role used by Lambda which handles the privatelink notifications
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: STSAssumeRole
                Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource: 
                  - 'arn:aws:iam::*:role/PLGovernanceConfigLambdaRole'
              - Sid: SNSOperations
                Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref  PLNotificationSnsTopic                 
  CentralPrivateLinkEventRule: 
    Type: AWS::Events::Rule
    Properties:
      EventBusName: default
      EventPattern:
        source:
          - aws.ec2
        detail-type:
          - AWS API Call via CloudTrail
        detail:
          eventSource:
            - ec2.amazonaws.com
          eventName:
            - CreateVpcEndpoint
            - AcceptVpcEndpointConnections
      Name: CentralPrivateLinkRule
      State: ENABLED
      Targets:
        - Arn: !GetAtt PLNotificationsLambda.Arn
          Id: PLLambda
    DependsOn: PLNotificationsLambdaInvokePermission      
  PLGovernanceAcceptCustomConfigRule:
    Type: 'AWS::Config::OrganizationConfigRule'
    Properties:
      OrganizationConfigRuleName: pl-governance-rule-accept
      OrganizationCustomRuleMetadata:
        MaximumExecutionFrequency: One_Hour
        ResourceTypesScope:
          - 'AWS::EC2::VPCEndpointService'
        LambdaFunctionArn: 
          'Fn::GetAtt':
            - PLConfigAcceptLambdaFunction
            - Arn
        OrganizationConfigRuleTriggerTypes:
          - "ConfigurationItemChangeNotification"
          - "OversizedConfigurationItemChangeNotification"
          - "ScheduledNotification"
    DependsOn: PLConfigAcceptLambdaInvokePermissions
  PLGovernanceNotificationCustomConfigRule:
    Type: 'AWS::Config::OrganizationConfigRule'
    Properties:
      OrganizationConfigRuleName: pl-governance-rule-notification
      OrganizationCustomRuleMetadata:
        MaximumExecutionFrequency: One_Hour
        ResourceTypesScope:
          - 'AWS::EC2::VPCEndpointService'        
        LambdaFunctionArn: 
          'Fn::GetAtt':
            - PLConfigNotificationLambdaFunction
            - Arn
        OrganizationConfigRuleTriggerTypes:
          - "ConfigurationItemChangeNotification"
          - "OversizedConfigurationItemChangeNotification"
          - "ScheduledNotification"
    DependsOn: PLConfigNotificationLambdaInvokePermissions
  PLConfigAcceptLambdaInvokePermissions:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName:
        'Fn::GetAtt':
          - PLConfigAcceptLambdaFunction
          - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  PLConfigNotificationLambdaInvokePermissions:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName:
        'Fn::GetAtt':
          - PLConfigNotificationLambdaFunction
          - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  PLConfigAcceptLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: "PLConfigAcceptLambdaFunction"
      Description: Function to handle notifications from privatelink services for AWS Config
      Handler: index.lambda_handler
      Role: 
        'Fn::GetAtt':
          - PLConfigLambdaRole
          - Arn
      Code:
        ZipFile: |
          import json
          import sys
          import datetime
          import boto3
          import botocore
          import os
          try:
              import liblogging
          except ImportError:
              pass

          ##############
          # Parameters #
          ##############

          # Define the default resource to report to Config Rules
          DEFAULT_RESOURCE_TYPE = 'AWS::EC2::VPCEndpointService'

          # Set to True to get the lambda to assume the Role attached on the Config Service (useful for cross-account).
          ASSUME_ROLE_MODE = True

          # Other parameters (no change needed)
          CONFIG_ROLE_TIMEOUT_SECONDS = 900

          #############
          # Main Code #
          #############

          def evaluate_compliance(event, configuration_item, valid_rule_parameters):
              ec2_client = get_client('ec2', event)
              evaluations = []
              for service in get_endpoint_services(ec2_client):
                  if not service['Owner'] == 'amazon':
                      if service['AcceptanceRequired']:
                          evaluations.append(build_evaluation(service['ServiceName'], 'COMPLIANT', event, DEFAULT_RESOURCE_TYPE))
                          print("VPC Endpoint Service is COMPLIANT = " + service['ServiceName'])
                          continue
                      else:
                          evaluations.append(build_evaluation(service['ServiceName'], 'NON_COMPLIANT', event, DEFAULT_RESOURCE_TYPE, annotation='The Endpoint Service has "AcceptanceRequired" set to False.'))
                          print("VPC Endpoint Service is NON COMPLIANT = " + service['ServiceName'])
              jsonStr = json.dumps(evaluations);
              print("Evaluation object = ", jsonStr)
              return evaluations

          def get_endpoint_services(ec2_client):
              endpoint_services = []
              response = ec2_client.describe_vpc_endpoint_services()
              while True:
                  endpoint_services.extend(response['ServiceDetails'])
                  if 'NextToken' in response:
                      response = ec2_client.describe_vpc_endpoint_services(NextToken=response['NextToken'])
                      continue
                  return endpoint_services

          def evaluate_parameters(rule_parameters):
              valid_rule_parameters = rule_parameters
              return valid_rule_parameters

          ####################
          # Helper Functions #
          ####################

          # Build an error to be displayed in the logs when the parameter is invalid.
          def build_parameters_value_error_response(ex):
              """Return an error dictionary when the evaluate_parameters() raises a ValueError.

              Keyword arguments:
              ex -- Exception text
              """
              return  build_error_response(internal_error_message="Parameter value is invalid",
                                          internal_error_details="An ValueError was raised during the validation of the Parameter value",
                                          customer_error_code="InvalidParameterValueException",
                                          customer_error_message=str(ex))

          # This gets the client after assuming the Config service role
          # either in the same AWS account or cross-account.
          def get_client(service, event):
              """Return the service boto client. It should be used instead of directly calling the client.

              Keyword arguments:
              service -- the service name used for calling the boto.client()
              event -- the event variable given in the lambda handler
              """
              if not ASSUME_ROLE_MODE:
                  return boto3.client(service)
              if(AWS_ACCOUNT_ID == event["accountId"]):
                  return boto3.client(service)

              roleArn = "arn:aws:iam::"+ event['accountId'] + ":role/" + os.environ['EXECUTION_ROLE']
              
              credentials = get_assume_role_credentials(roleArn)
              return boto3.client(service, aws_access_key_id=credentials['AccessKeyId'],
                                  aws_secret_access_key=credentials['SecretAccessKey'],
                                  aws_session_token=credentials['SessionToken']
                                )

          # This generate an evaluation for config
          def build_evaluation(resource_id, compliance_type, event, resource_type=DEFAULT_RESOURCE_TYPE, annotation=None):
              """Form an evaluation as a dictionary. Usually suited to report on scheduled rules.

              Keyword arguments:
              resource_id -- the unique id of the resource to report
              compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
              event -- the event variable given in the lambda handler
              resource_type -- the CloudFormation resource type (or AWS::::Account) to report on the rule (default DEFAULT_RESOURCE_TYPE)
              annotation -- an annotation to be added to the evaluation (default None)
              """
              eval_cc = {}
              if annotation:
                  eval_cc['Annotation'] = annotation
              eval_cc['ComplianceResourceType'] = resource_type
              eval_cc['ComplianceResourceId'] = resource_id
              eval_cc['ComplianceType'] = compliance_type
              eval_cc['OrderingTimestamp'] = str(json.loads(event['invokingEvent'])['notificationCreationTime'])
              return eval_cc

          def build_evaluation_from_config_item(configuration_item, compliance_type, annotation=None):
              """Form an evaluation as a dictionary. Usually suited to report on configuration change rules.

              Keyword arguments:
              configuration_item -- the configurationItem dictionary in the invokingEvent
              compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
              annotation -- an annotation to be added to the evaluation (default None)
              """
              eval_ci = {}
              if annotation:
                  eval_ci['Annotation'] = annotation
              eval_ci['ComplianceResourceType'] = configuration_item['resourceType']
              eval_ci['ComplianceResourceId'] = configuration_item['resourceId']
              eval_ci['ComplianceType'] = compliance_type
              eval_ci['OrderingTimestamp'] = configuration_item['configurationItemCaptureTime']
              return eval_ci

          ####################
          # Boilerplate Code #
          ####################

          # Helper function used to validate input
          def check_defined(reference, reference_name):
              if not reference:
                  raise Exception('Error: ', reference_name, 'is not defined')
              return reference

          # Check whether the message is OversizedConfigurationItemChangeNotification or not
          def is_oversized_changed_notification(message_type):
              check_defined(message_type, 'messageType')
              return message_type == 'OversizedConfigurationItemChangeNotification'

          # Check whether the message is a ScheduledNotification or not.
          def is_scheduled_notification(message_type):
              check_defined(message_type, 'messageType')
              return message_type == 'ScheduledNotification'

          # Get configurationItem using getResourceConfigHistory API
          # in case of OversizedConfigurationItemChangeNotification
          def get_configuration(resource_type, resource_id, configuration_capture_time):
              result = AWS_CONFIG_CLIENT.get_resource_config_history(
                  resourceType=resource_type,
                  resourceId=resource_id,
                  laterTime=configuration_capture_time,
                  limit=1)
              configuration_item = result['configurationItems'][0]
              return convert_api_configuration(configuration_item)

          # Convert from the API model to the original invocation model
          def convert_api_configuration(configuration_item):
              for k, v in configuration_item.items():
                  if isinstance(v, datetime.datetime):
                      configuration_item[k] = str(v)
              configuration_item['awsAccountId'] = configuration_item['accountId']
              configuration_item['ARN'] = configuration_item['arn']
              configuration_item['configurationStateMd5Hash'] = configuration_item['configurationItemMD5Hash']
              configuration_item['configurationItemVersion'] = configuration_item['version']
              configuration_item['configuration'] = json.loads(configuration_item['configuration'])
              if 'relationships' in configuration_item:
                  for i in range(len(configuration_item['relationships'])):
                      configuration_item['relationships'][i]['name'] = configuration_item['relationships'][i]['relationshipName']
              return configuration_item

          # Based on the type of message get the configuration item
          # either from configurationItem in the invoking event
          # or using the getResourceConfigHistiry API in getConfiguration function.
          def get_configuration_item(invoking_event):
              check_defined(invoking_event, 'invokingEvent')
              if is_oversized_changed_notification(invoking_event['messageType']):
                  configuration_item_summary = check_defined(invoking_event['configuration_item_summary'], 'configurationItemSummary')
                  return get_configuration(configuration_item_summary['resourceType'], configuration_item_summary['resourceId'], configuration_item_summary['configurationItemCaptureTime'])
              if is_scheduled_notification(invoking_event['messageType']):
                  return None
              return check_defined(invoking_event['configurationItem'], 'configurationItem')

          # Check whether the resource has been deleted. If it has, then the evaluation is unnecessary.
          def is_applicable(configuration_item, event):
              try:
                  check_defined(configuration_item, 'configurationItem')
                  check_defined(event, 'event')
              except:
                  return True
              status = configuration_item['configurationItemStatus']
              event_left_scope = event['eventLeftScope']
              if status == 'ResourceDeleted':
                  print("Resource Deleted, setting Compliance Status to NOT_APPLICABLE.")
              return status in ('OK', 'ResourceDiscovered') and not event_left_scope

          def get_assume_role_credentials(role_arn):
              sts_client = boto3.client('sts')
              try:
                  assume_role_response = sts_client.assume_role(RoleArn=role_arn,
                                                                RoleSessionName="configLambdaExecution",
                                                                DurationSeconds=CONFIG_ROLE_TIMEOUT_SECONDS)
                  if 'liblogging' in sys.modules:
                      liblogging.logSession(role_arn, assume_role_response)
                  return assume_role_response['Credentials']
              except botocore.exceptions.ClientError as ex:
                  # Scrub error message for any internal account info leaks
                  print(str(ex))
                  if 'AccessDenied' in ex.response['Error']['Code']:
                      ex.response['Error']['Message'] = "AWS Config does not have permission to assume the IAM role."
                  else:
                      ex.response['Error']['Message'] = "InternalError"
                      ex.response['Error']['Code'] = "InternalError"
                  raise ex

          # This removes older evaluation (usually useful for periodic rule not reporting on AWS::::Account).
          def clean_up_old_evaluations(latest_evaluations, event):

              cleaned_evaluations = []

              old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                  ConfigRuleName=event['configRuleName'],
                  ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                  Limit=100)

              old_eval_list = []

              while True:
                  for old_result in old_eval['EvaluationResults']:
                      old_eval_list.append(old_result)
                  if 'NextToken' in old_eval:
                      next_token = old_eval['NextToken']
                      old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                          ConfigRuleName=event['configRuleName'],
                          ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                          Limit=100,
                          NextToken=next_token)
                  else:
                      break

              for old_eval in old_eval_list:
                  old_resource_id = old_eval['EvaluationResultIdentifier']['EvaluationResultQualifier']['ResourceId']
                  newer_founded = False
                  for latest_eval in latest_evaluations:
                      if old_resource_id == latest_eval['ComplianceResourceId']:
                          newer_founded = True
                  if not newer_founded:
                      cleaned_evaluations.append(build_evaluation(old_resource_id, "NOT_APPLICABLE", event))

              return cleaned_evaluations + latest_evaluations

          def lambda_handler(event, context):
              if 'liblogging' in sys.modules:
                  liblogging.logEvent(event)
              global AWS_ACCOUNT_ID
              global AWS_CONFIG_CLIENT
              
              print ("lambda arn: " + context.invoked_function_arn)
              
              # Get Account ID from lambda function arn in the context
              AWS_ACCOUNT_ID = context.invoked_function_arn.split(":")[4]
              print ("Account ID=" + AWS_ACCOUNT_ID)
              
              jsonObj = json.dumps(event)
              print(jsonObj)
              print(event)
              check_defined(event, 'event')
              invoking_event = json.loads(event['invokingEvent'])
              jsonObj2 = json.dumps(invoking_event)
              print(jsonObj2)
              rule_parameters = {}
              if 'ruleParameters' in event:
                  rule_parameters = json.loads(event['ruleParameters'])

              try:
                  valid_rule_parameters = evaluate_parameters(rule_parameters)
              except ValueError as ex:
                  return build_parameters_value_error_response(ex)

              try:
                  AWS_CONFIG_CLIENT = get_client('config', event)
                  if invoking_event['messageType'] in ['ConfigurationItemChangeNotification', 'ScheduledNotification', 'OversizedConfigurationItemChangeNotification']:
                      configuration_item = get_configuration_item(invoking_event)
                      if is_applicable(configuration_item, event):
                          if(AWS_ACCOUNT_ID != event["accountId"]):
                              compliance_result = evaluate_compliance(event, configuration_item, valid_rule_parameters)
                          else:
                            compliance_result = "NOT_APPLICABLE"                              
                      else:
                          compliance_result = "NOT_APPLICABLE"
                  else:
                      return build_internal_error_response('Unexpected message type', str(invoking_event))
              except botocore.exceptions.ClientError as ex:
                  if is_internal_error(ex):
                      return build_internal_error_response("Unexpected error while completing API request", str(ex))
                  return build_error_response("Customer error while making API request", str(ex), ex.response['Error']['Code'], ex.response['Error']['Message'])
              except ValueError as ex:
                  return build_internal_error_response(str(ex), str(ex))

              evaluations = []
              latest_evaluations = []

              if not compliance_result:
                  latest_evaluations.append(build_evaluation(event['accountId'], "NOT_APPLICABLE", event, resource_type='AWS::::Account'))
                  evaluations = clean_up_old_evaluations(latest_evaluations, event)
              elif isinstance(compliance_result, str):
                  if configuration_item:
                      evaluations.append(build_evaluation_from_config_item(configuration_item, compliance_result))
                  else:
                      evaluations.append(build_evaluation(event['accountId'], compliance_result, event, resource_type=DEFAULT_RESOURCE_TYPE))
              elif isinstance(compliance_result, list):
                  for evaluation in compliance_result:
                      missing_fields = False
                      for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                          if field not in evaluation:
                              print("Missing " + field + " from custom evaluation.")
                              missing_fields = True

                      if not missing_fields:
                          latest_evaluations.append(evaluation)
                  evaluations = clean_up_old_evaluations(latest_evaluations, event)
              elif isinstance(compliance_result, dict):
                  missing_fields = False
                  for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                      if field not in compliance_result:
                          print("Missing " + field + " from custom evaluation.")
                          missing_fields = True
                  if not missing_fields:
                      evaluations.append(compliance_result)
              else:
                  evaluations.append(build_evaluation_from_config_item(configuration_item, 'NOT_APPLICABLE'))

              # Put together the request that reports the evaluation status
              result_token = event['resultToken']
              test_mode = False
              if result_token == 'TESTMODE':
                  # Used solely for RDK test to skip actual put_evaluation API call
                  test_mode = True

              # Invoke the Config API to report the result of the evaluation
              evaluation_copy = []
              evaluation_copy = evaluations[:]
              jsonStr2 = json.dumps(evaluations)
              print("Final Evaluation Copy = ", jsonStr2)
              print("Final ResultToken = ", result_token)
              while evaluation_copy:
                  AWS_CONFIG_CLIENT.put_evaluations(Evaluations=evaluation_copy[:100], ResultToken=result_token, TestMode=test_mode)
                  del evaluation_copy[:100]

              # Used solely for RDK test to be able to test Lambda function
              return evaluations

          def is_internal_error(exception):
              return ((not isinstance(exception, botocore.exceptions.ClientError)) or exception.response['Error']['Code'].startswith('5')
                      or 'InternalError' in exception.response['Error']['Code'] or 'ServiceError' in exception.response['Error']['Code'])

          def build_internal_error_response(internal_error_message, internal_error_details=None):
              return build_error_response(internal_error_message, internal_error_details, 'InternalError', 'InternalError')

          def build_error_response(internal_error_message, internal_error_details=None, customer_error_code=None, customer_error_message=None):
              error_response = {
                  'internalErrorMessage': internal_error_message,
                  'internalErrorDetails': internal_error_details,
                  'customerErrorMessage': customer_error_message,
                  'customerErrorCode': customer_error_code
              }
              print(error_response)
              return error_response
      Runtime: python3.12
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          MASTER_ACCOUNT: !Ref 'AWS::AccountId'
          EXECUTION_ROLE: 'PLGovernanceConfigLambdaRole'
  PLConfigNotificationLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: "PLConfigNotificationLambdaFunction"
      Description: Function to handle notifications from privatelink services for AWS Config
      Handler: index.lambda_handler
      Role: 
        'Fn::GetAtt':
          - PLConfigLambdaRole
          - Arn
      Code:
        ZipFile: |
            # Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
            #
            # Licensed under the Apache License, Version 2.0 (the "License"). You may
            # not use this file except in compliance with the License. A copy of the License is located at
            #
            #        http://aws.amazon.com/apache2.0/
            #
            # or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS,
            # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
            # the specific language governing permissions and limitations under the License.

            '''
            #####################################
            ##           Gherkin               ##
            #####################################
            Rule Name:
                VPC_ENDPOINT_NOTIFICATIONS

            Description:
                Checks whether the VPC Endpoint Service have notifications enabled. The rule is NON_COMPLIANT if VPC Endpoint Service is not configured with Notifications

            Trigger:
                Periodic

            Reports on:
                AWS::EC2::VPCEndpointConnectionNotification

            Rule Parameters:
            None

            Scenarios:
            Scenario: 1
                Given: No customer-owned VPC Endpoint Service is present.
                Then: Return NOT_APPLICABLE

            Scenario: 2
                Given: At least one customer-owned VPC Endpoint Service is present.
                And: "ConnectionNotificationID" Key is not present for DescribeVpcEndpoint connection notifications
                Then: Return NON_COMPLIANT

            Scenario: 3
                Given: At least one customer-owned VPC Endpoint Service is present.
                And: ConnectionNotificationID" Key is present for DescribeVpcEndpoint connection notifications
                Then: Return COMPLIANT
            '''

            import json
            import sys
            import datetime
            import boto3
            import botocore
            import logging
            import os

            try:
                import liblogging
            except ImportError:
                pass

            ##############
            # Parameters #
            ##############

            # Define the default resource to report to Config Rules
            DEFAULT_RESOURCE_TYPE = 'AWS::EC2::VPCEndpointConnectionNotification'

            # Set to True to get the lambda to assume the Role attached on the Config Service (useful for cross-account).
            ASSUME_ROLE_MODE = True

            # Other parameters (no change needed)
            CONFIG_ROLE_TIMEOUT_SECONDS = 900

            #############
            # Main Code #
            #############

            def evaluate_compliance(event, configuration_item, valid_rule_parameters):
                ec2_client= get_client('ec2', event)
                ec2_client_notification= get_client('ec2', event)
                evaluations = []
                for service in get_endpoint_services(ec2_client):
                    if not service['Owner'] == 'amazon':
                        for notification in get_endpoint_notifications(ec2_client_notification):
                            if service['ServiceId'] == notification['ServiceId']:
                                evaluations.append(build_evaluation(service['ServiceId'], 'COMPLIANT', event, DEFAULT_RESOURCE_TYPE, annotation='The Endpoint Service does not have notifications enabled'))
                                print("VPC Endpoint Service is COMPLIANT = " + service['ServiceName'])
                                jsonStr = json.dumps(evaluations);
                                print("Evaluation object = ", jsonStr)
                                return evaluations
                        evaluations.append(build_evaluation(service['ServiceId'], 'NON_COMPLIANT', event, DEFAULT_RESOURCE_TYPE, annotation='The Endpoint Service does not have notifications enabled'))
                        print("VPC Endpoint Service is NON COMPLIANT = " + service['ServiceName'])                   
                
                jsonStr = json.dumps(evaluations);
                print("Evaluation object = ", jsonStr)
                return evaluations

            def get_endpoint_services(ec2_client):
                endpoint_services = []
                response = ec2_client.describe_vpc_endpoint_services()
                while True:
                    endpoint_services.extend(response['ServiceDetails'])
                    if 'NextToken' in response:
                        response = ec2_client.describe_vpc_endpoint_services(NextToken=response['NextToken'])
                        continue
                    return endpoint_services

            def get_endpoint_notifications(ec2_client_notification):
                endpoint_services_notifications = []
                response = ec2_client_notification.describe_vpc_endpoint_connection_notifications()
                while True:
                    endpoint_services_notifications.extend(response['ConnectionNotificationSet'])
                    if 'NextToken' in response:
                        response = ec2_client_notification.describe_vpc_endpoint_connection_notifications(NextToken=response['NextToken'])
                        continue
                    return endpoint_services_notifications
                    
            def evaluate_parameters(rule_parameters):
                valid_rule_parameters = rule_parameters
                return valid_rule_parameters

            ####################
            # Helper Functions #
            ####################

            # Build an error to be displayed in the logs when the parameter is invalid.
            def build_parameters_value_error_response(ex):
                """Return an error dictionary when the evaluate_parameters() raises a ValueError.

                Keyword arguments:
                ex -- Exception text
                """
                return  build_error_response(internal_error_message="Parameter value is invalid",
                                            internal_error_details="An ValueError was raised during the validation of the Parameter value",
                                            customer_error_code="InvalidParameterValueException",
                                            customer_error_message=str(ex))

            # This gets the client after assuming the Config service role
            # either in the same AWS account or cross-account.
            def get_client(service, event):
                """Return the service boto client. It should be used instead of directly calling the client.

                Keyword arguments:
                service -- the service name used for calling the boto.client()
                event -- the event variable given in the lambda handler
                """
                if not ASSUME_ROLE_MODE:
                    return boto3.client(service)
                if(AWS_ACCOUNT_ID == event["accountId"]):
                    return boto3.client(service)
                roleArn = "arn:aws:iam::"+ event['accountId'] + ":role/" + os.environ['EXECUTION_ROLE']

                credentials = get_assume_role_credentials(roleArn)
                return boto3.client(service, aws_access_key_id=credentials['AccessKeyId'],
                                    aws_secret_access_key=credentials['SecretAccessKey'],
                                    aws_session_token=credentials['SessionToken']
                                )

            # This generate an evaluation for config
            def build_evaluation(resource_id, compliance_type, event, resource_type=DEFAULT_RESOURCE_TYPE, annotation=None):
                """Form an evaluation as a dictionary. Usually suited to report on scheduled rules.

                Keyword arguments:
                resource_id -- the unique id of the resource to report
                compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
                event -- the event variable given in the lambda handler
                resource_type -- the CloudFormation resource type (or AWS::::Account) to report on the rule (default DEFAULT_RESOURCE_TYPE)
                annotation -- an annotation to be added to the evaluation (default None)
                """
                eval_cc = {}
                if annotation:
                    eval_cc['Annotation'] = annotation
                eval_cc['ComplianceResourceType'] = resource_type
                eval_cc['ComplianceResourceId'] = resource_id
                eval_cc['ComplianceType'] = compliance_type
                eval_cc['OrderingTimestamp'] = str(json.loads(event['invokingEvent'])['notificationCreationTime'])
                return eval_cc

            def build_evaluation_from_config_item(configuration_item, compliance_type, annotation=None):
                """Form an evaluation as a dictionary. Usually suited to report on configuration change rules.

                Keyword arguments:
                configuration_item -- the configurationItem dictionary in the invokingEvent
                compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
                annotation -- an annotation to be added to the evaluation (default None)
                """
                eval_ci = {}
                if annotation:
                    eval_ci['Annotation'] = annotation
                eval_ci['ComplianceResourceType'] = configuration_item['resourceType']
                eval_ci['ComplianceResourceId'] = configuration_item['resourceId']
                eval_ci['ComplianceType'] = compliance_type
                eval_ci['OrderingTimestamp'] = configuration_item['configurationItemCaptureTime']
                return eval_ci

            ####################
            # Boilerplate Code #
            ####################

            # Helper function used to validate input
            def check_defined(reference, reference_name):
                if not reference:
                    raise Exception('Error: ', reference_name, 'is not defined')
                return reference

            # Check whether the message is OversizedConfigurationItemChangeNotification or not
            def is_oversized_changed_notification(message_type):
                check_defined(message_type, 'messageType')
                return message_type == 'OversizedConfigurationItemChangeNotification'

            # Check whether the message is a ScheduledNotification or not.
            def is_scheduled_notification(message_type):
                check_defined(message_type, 'messageType')
                return message_type == 'ScheduledNotification'

            # Get configurationItem using getResourceConfigHistory API
            # in case of OversizedConfigurationItemChangeNotification
            def get_configuration(resource_type, resource_id, configuration_capture_time):
                result = AWS_CONFIG_CLIENT.get_resource_config_history(
                    resourceType=resource_type,
                    resourceId=resource_id,
                    laterTime=configuration_capture_time,
                    limit=1)
                configuration_item = result['configurationItems'][0]
                return convert_api_configuration(configuration_item)

            # Convert from the API model to the original invocation model
            def convert_api_configuration(configuration_item):
                for k, v in configuration_item.items():
                    if isinstance(v, datetime.datetime):
                        configuration_item[k] = str(v)
                configuration_item['awsAccountId'] = configuration_item['accountId']
                configuration_item['ARN'] = configuration_item['arn']
                configuration_item['configurationStateMd5Hash'] = configuration_item['configurationItemMD5Hash']
                configuration_item['configurationItemVersion'] = configuration_item['version']
                configuration_item['configuration'] = json.loads(configuration_item['configuration'])
                if 'relationships' in configuration_item:
                    for i in range(len(configuration_item['relationships'])):
                        configuration_item['relationships'][i]['name'] = configuration_item['relationships'][i]['relationshipName']
                return configuration_item

            # Based on the type of message get the configuration item
            # either from configurationItem in the invoking event
            # or using the getResourceConfigHistiry API in getConfiguration function.
            def get_configuration_item(invoking_event):
                check_defined(invoking_event, 'invokingEvent')
                if is_oversized_changed_notification(invoking_event['messageType']):
                    configuration_item_summary = check_defined(invoking_event['configuration_item_summary'], 'configurationItemSummary')
                    return get_configuration(configuration_item_summary['resourceType'], configuration_item_summary['resourceId'], configuration_item_summary['configurationItemCaptureTime'])
                if is_scheduled_notification(invoking_event['messageType']):
                    return None
                return check_defined(invoking_event['configurationItem'], 'configurationItem')

            # Check whether the resource has been deleted. If it has, then the evaluation is unnecessary.
            def is_applicable(configuration_item, event):
                try:
                    check_defined(configuration_item, 'configurationItem')
                    check_defined(event, 'event')
                except:
                    return True
                status = configuration_item['configurationItemStatus']
                event_left_scope = event['eventLeftScope']
                if status == 'ResourceDeleted':
                    print("Resource Deleted, setting Compliance Status to NOT_APPLICABLE.")
                return status in ('OK', 'ResourceDiscovered') and not event_left_scope

            def get_assume_role_credentials(role_arn):
                sts_client = boto3.client('sts')
                try:
                    assume_role_response = sts_client.assume_role(RoleArn=role_arn,
                                                                RoleSessionName="configLambdaExecution",
                                                                DurationSeconds=CONFIG_ROLE_TIMEOUT_SECONDS)
                    if 'liblogging' in sys.modules:
                        liblogging.logSession(role_arn, assume_role_response)
                    return assume_role_response['Credentials']
                except botocore.exceptions.ClientError as ex:
                    # Scrub error message for any internal account info leaks
                    print(str(ex))
                    if 'AccessDenied' in ex.response['Error']['Code']:
                        ex.response['Error']['Message'] = "AWS Config does not have permission to assume the IAM role."
                    else:
                        ex.response['Error']['Message'] = "InternalError"
                        ex.response['Error']['Code'] = "InternalError"
                    raise ex

            # This removes older evaluation (usually useful for periodic rule not reporting on AWS::::Account).
            def clean_up_old_evaluations(latest_evaluations, event):

                cleaned_evaluations = []

                old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                    ConfigRuleName=event['configRuleName'],
                    ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                    Limit=100)

                old_eval_list = []

                while True:
                    for old_result in old_eval['EvaluationResults']:
                        old_eval_list.append(old_result)
                    if 'NextToken' in old_eval:
                        next_token = old_eval['NextToken']
                        old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                            ConfigRuleName=event['configRuleName'],
                            ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                            Limit=100,
                            NextToken=next_token)
                    else:
                        break

                for old_eval in old_eval_list:
                    old_resource_id = old_eval['EvaluationResultIdentifier']['EvaluationResultQualifier']['ResourceId']
                    newer_founded = False
                    for latest_eval in latest_evaluations:
                        if old_resource_id == latest_eval['ComplianceResourceId']:
                            newer_founded = True
                    if not newer_founded:
                        cleaned_evaluations.append(build_evaluation(old_resource_id, "NOT_APPLICABLE", event))

                return cleaned_evaluations + latest_evaluations

            def lambda_handler(event, context):
                if 'liblogging' in sys.modules:
                    liblogging.logEvent(event)
                global AWS_ACCOUNT_ID
                global AWS_CONFIG_CLIENT
                print ("lambda arn: " + context.invoked_function_arn)
                
                # Get Account ID from lambda function arn in the context
                AWS_ACCOUNT_ID = context.invoked_function_arn.split(":")[4]
                print ("Account ID=" + AWS_ACCOUNT_ID)
                
                jsonObj = json.dumps(event)
                print(jsonObj)
                print(event)

                check_defined(event, 'event')
                invoking_event = json.loads(event['invokingEvent'])
                jsonObj2 = json.dumps(invoking_event)
                print(jsonObj2)
                rule_parameters = {}
                if 'ruleParameters' in event:
                    rule_parameters = json.loads(event['ruleParameters'])

                try:
                    valid_rule_parameters = evaluate_parameters(rule_parameters)
                except ValueError as ex:
                    return build_parameters_value_error_response(ex)

                try:
                    AWS_CONFIG_CLIENT = get_client('config', event)
                    if invoking_event['messageType'] in ['ConfigurationItemChangeNotification', 'ScheduledNotification', 'OversizedConfigurationItemChangeNotification']:
                        configuration_item = get_configuration_item(invoking_event)
                        if is_applicable(configuration_item, event):
                            if(AWS_ACCOUNT_ID != event["accountId"]):
                                compliance_result = evaluate_compliance(event, configuration_item, valid_rule_parameters)
                            else:
                                compliance_result = "NOT_APPLICABLE"                            
                        else:
                            compliance_result = "NOT_APPLICABLE"
                    else:
                        return build_internal_error_response('Unexpected message type', str(invoking_event))
                except botocore.exceptions.ClientError as ex:
                    if is_internal_error(ex):
                        return build_internal_error_response("Unexpected error while completing API request", str(ex))
                    return build_error_response("Customer error while making API request", str(ex), ex.response['Error']['Code'], ex.response['Error']['Message'])
                except ValueError as ex:
                    return build_internal_error_response(str(ex), str(ex))

                evaluations = []
                latest_evaluations = []

                if not compliance_result:
                    latest_evaluations.append(build_evaluation(event['accountId'], "NOT_APPLICABLE", event, resource_type='AWS::::Account'))
                    evaluations = clean_up_old_evaluations(latest_evaluations, event)
                elif isinstance(compliance_result, str):
                    if configuration_item:
                        evaluations.append(build_evaluation_from_config_item(configuration_item, compliance_result))
                    else:
                        evaluations.append(build_evaluation(event['accountId'], compliance_result, event, resource_type=DEFAULT_RESOURCE_TYPE))
                elif isinstance(compliance_result, list):
                    for evaluation in compliance_result:
                        missing_fields = False
                        for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                            if field not in evaluation:
                                print("Missing " + field + " from custom evaluation.")
                                missing_fields = True

                        if not missing_fields:
                            latest_evaluations.append(evaluation)
                    evaluations = clean_up_old_evaluations(latest_evaluations, event)
                elif isinstance(compliance_result, dict):
                    missing_fields = False
                    for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                        if field not in compliance_result:
                            print("Missing " + field + " from custom evaluation.")
                            missing_fields = True
                    if not missing_fields:
                        evaluations.append(compliance_result)
                else:
                    evaluations.append(build_evaluation_from_config_item(configuration_item, 'NOT_APPLICABLE'))

                # Put together the request that reports the evaluation status
                result_token = event['resultToken']
                test_mode = False
                if result_token == 'TESTMODE':
                    # Used solely for RDK test to skip actual put_evaluation API call
                    test_mode = True

                # Invoke the Config API to report the result of the evaluation
                evaluation_copy = []
                evaluation_copy = evaluations[:]
                jsonStr2 = json.dumps(evaluations)
                print("Final Evaluation Copy = ", jsonStr2)
                print("Final ResultToken = ", result_token)

                while evaluation_copy:
                    AWS_CONFIG_CLIENT.put_evaluations(Evaluations=evaluation_copy[:100], ResultToken=result_token, TestMode=test_mode)
                    del evaluation_copy[:100]

                # Used solely for RDK test to be able to test Lambda function
                return evaluations

            def is_internal_error(exception):
                return ((not isinstance(exception, botocore.exceptions.ClientError)) or exception.response['Error']['Code'].startswith('5')
                        or 'InternalError' in exception.response['Error']['Code'] or 'ServiceError' in exception.response['Error']['Code'])

            def build_internal_error_response(internal_error_message, internal_error_details=None):
                return build_error_response(internal_error_message, internal_error_details, 'InternalError', 'InternalError')

            def build_error_response(internal_error_message, internal_error_details=None, customer_error_code=None, customer_error_message=None):
                error_response = {
                    'internalErrorMessage': internal_error_message,
                    'internalErrorDetails': internal_error_details,
                    'customerErrorMessage': customer_error_message,
                    'customerErrorCode': customer_error_code
                }
                print(error_response)
                return error_response
      Runtime: python3.12
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          MASTER_ACCOUNT: !Ref 'AWS::AccountId'
          EXECUTION_ROLE: 'PLGovernanceConfigLambdaRole'
  PLConfigLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: 'PLConfigLambdaRole'    
      Description: Role used by Lambda which handles the privatelink notifications
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AssumeCrossAccountRolePolicyforConfigLambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: STSAssumeRole
                Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource: 
                  - 'arn:aws:iam::*:role/PLGovernanceConfigLambdaRole'
              - Sid: ConfigOperations
                Effect: Allow
                Action:
                  - config:PutEvaluations
                  - config:GetComplianceDetailsByConfigRule
                  - config:GetResourceConfigHistory
                Resource: '*'
              - Sid: EC2Operations
                Effect: Allow
                Action:
                  - ec2:DescribeVpcEndpointServices
                  - ec2:DescribeVpcEndpointConnectionNotifications
                Resource: '*'
